	// ---- 2. 启动MMU ----
	// ARM体系架构与编程; 嵌入汇编：LINUX内核完全注释
		// ARM体系结构中, 存储系统通常是通过系统控制协处理器CP15完成的
		// CP15包含16个32位的寄存器，其编号为0~15。
		// MCR   ARM寄存器到协处理器寄存器的数据传送
				// MCR指令将ARM处理器的寄存器中的数据传送到协处理器的寄存器中。
				// 如果协处理器不能成功地执行该操作，将产生未定义的指令异常中断。
		// MRC   协处理器寄存器到ARM寄存器的数据传送
	// 参考: http://6xudonghai.blog.163.com/blog/static/336406292008724103317304/
	__asm__ (
			"mov    r1, #0\n"
			// 将寄存器r1的值传给p15协处理器的c7寄存器;
			// p15-c7, Cache operations,用于管理指令缓存和数据缓存。 只可写;
			// 对该寄存器的写操作所实现的功能，是通过MCR指令中的opcode_2和CRm两者的组合来选择的，具体组合详见数据手册。
			"mcr    p15, 0, r1, c7, c7, 0\n"    /* 使无效ICaches和DCaches */
			// MCR{cond}   p15,{opcode_1},<Rd>,<CRn>,<CRm>{,opcode_2}
			// MCR2        p15,{opcode_1},<Rd>,<CRn>,<CRm>{,opcode_2}
				// p15, 指定协处理器
				// <cond>为指令执行的条件码, 当<cond>忽略时指令为无条件执行。
				// <opcode_1>为协处理器将执行的操作的操作码。对于CP15协处理器来说， <opcode_1>永远为0b000,当<opcode_1>不为0b000时，该指令操作结果不可预知。 
				// <Rd>作为元寄存器的ARM寄存器，其值被传送到得协处理器寄存器中。 <Rd>不能为PC，当其为PC时，指令操作结果不可预知。 
				// <CRn>作为目标寄存器的协处理器寄存器，其编号可能为C0,C1....,C15。   
				// <CRm>作为"附加的"目标寄存器或者原操作数寄存器，用于区分同一个编号的不同物理寄存器;如果不需要，就将它设置为C0，否则结果不可预知;
				// <opcode_2>提供附加信息，用于区别同一个编号的不同物理寄存器。当指令中指定附加信息时，省略<opcode_2>或者将其指定为0,否则指令操作结果不可预知。
			"mcr    p15, 0, r1, c7, c10, 4\n"   /* drain write buffer on v4 */
			// 将寄存器r1的值传给p15协处理器的c8寄存器;
			// p15-c8, TLB operations, 管理TLB, 只可写;
			"mcr    p15, 0, r1, c8, c7, 0\n"    /* 使无效指令、数据TLB */

			// 将占位符%0的值传给p15协处理器的c2寄存器;
			// p15-c2, Translation table base, 页表基址寄存器;
			// p15-c3, Domain access control, 访问域权限控制器;
			"mcr p15, 0, %0, c2, c0, 0\n" /* write TTB register */
			"mrc p15, 0, r1, c3, c0, 0\n" /* read domain 15:0 access permissions */
			"orr r1, r1, #3\n"            /* domain 0, Accesses are not checked */
			"mcr p15, 0, r1, c3, c0, 0\n" /* write domain 15:0 access permissions */

			// 对于控制寄存器，先读出其值，在这基础上修改特定位, 然后再写入;
			"mrc p15, 0, r1, c1, c0, 0\n" /* Read control register */
			/* 控制寄存器的低16位含义为：.RVI ..RS B... .CAM
			 * [14], RR : Round robin replacement, 表示换出Cache中的条目时使用的算法，
			 *     		  0 = Random replacement；1 = Round robin replacement
			 * [13], V : 表示异常向量表所在的位置，
			 *     		 0 = Low addresses = 0x00000000；1 = High addresses = 0xFFFF0000
			 * [12], I : 0 = 关闭ICaches；1 = 开启ICaches
			 * [9:8],R、S : 用来与页表中的描述符一起确定内存的访问权限
			 * [7],  B : 0 = CPU为小字节序；1 = CPU为大字节序
			 * [2],  C : 0 = 关闭DCaches；1 = 开启DCaches
			 * [1],  A : 0 = 数据访问时不进行地址对齐检查；1 = 数据访问时进行地址对齐检查
			 * [0],  M : 0 = 关闭MMU；1 = 开启MMU
